"""Plotting of Figure 5: spatial correlation of errors for the Mont-Blanc case study"""
import numpy as np
import pandas as pd
import xdem
import geoutils as gu
import matplotlib.pyplot as plt
import skgstat as skg
from matplotlib import colors
import cartopy.crs as ccrs
import matplotlib.patches as mpatches
import matplotlib.ticker as ticker

plt.rcParams.update({'font.size': 12})
plt.rcParams.update({'pdf.fonttype':42})
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams["text.usetex"] = True

# Input files are generated by "estimate_heterosc_spatialcorr.py" in case_study_montblanc/

# Open files on:
# Heteroscedasticity
df_sub = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_heteroscedas_slope_curv.csv')

# Standardized elevation difference map
std_r = gu.Raster('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/dh_NK_Deramp_std_customforest.tif')

# Empirical variograms on stable and glacierized terrain
df_vgm_sta = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_vgm_sta.csv')
df_vgm_gla = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_vgm_gla.csv')
df_std_sta = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_vgm_std_sta.csv')
df_std_gla = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_vgm_std_gla.csv')

 # Results of patches method on stable and glacierized terrain
df_all_patches = pd.read_csv('/home/atom/ongoing/work_stderr_dem/case_study_montblanc/df_patches_sta_gla.csv')

# Filter lags higher than the half distance of each study domain and compute standard error from 100 realizations
df_vgm_sta = df_vgm_sta[df_vgm_sta.bins<30000]
df_vgm_sta.err_exp /= np.sqrt(100)/2
df_vgm_gla = df_vgm_gla[df_vgm_gla.bins<30000]
df_vgm_gla.err_exp /= np.sqrt(100)/2

df_std_sta = df_std_sta[df_std_sta.bins<30000]
df_std_sta.err_exp /= np.sqrt(100)/2
df_std_gla = df_std_gla[df_std_gla.bins<30000]
df_std_gla.err_exp /= np.sqrt(100)/2

# Re-standardize variogram with long-range lags
# (for plotting purposes only, already done in the uncertainty propagation functions)
std_fac_gla = np.nanmean(df_std_gla.exp.values[-3:])
df_std_gla.exp /= std_fac_gla
df_std_gla.err_exp /= std_fac_gla
std_fac_sta = np.nanmean(df_std_sta.exp.values[-3:])
df_std_sta.exp /= std_fac_sta
df_std_sta.err_exp /= std_fac_sta

# Model both variograms by a sum of models
fun1, params = xdem.spatialstats.fit_sum_model_variogram(list_model=['Gau', 'Sph', 'Sph'], empirical_variogram=df_std_sta,
                                                         bounds=[(0, 200), (0, 9), (500, 5000), (0, 9), (2000, 15000), (0,9)],
                                                         p0=[100, 1.5, 2000,1.5, 5000,1.5])
fun2, params2 = xdem.spatialstats.fit_sum_model_variogram(list_model=['Gau', 'Sph', 'Sph'], empirical_variogram=df_std_gla,
                                                          bounds=[(0, 200), (0, 9), (500, 5000), (0, 9), (2000, 15000), (0,9)],
                                                          p0=[100, 1.5, 2000, 1.5, 5000, 1.5])
# fun1, params = xdem.spatialstats.fit_sum_model_variogram(list_model=['Gau', 'Sph'], empirical_variogram=df_std_sta,
#                                                          bounds=[(0, 200), (0, 9), (500, 5000), (0, 9)],
#                                                          p0=[100, 1.5, 2000,1.5])
# fun2, params2 = xdem.spatialstats.fit_sum_model_variogram(list_model=['Gau', 'Sph'], empirical_variogram=df_std_gla,
#                                                           bounds=[(0, 200), (0, 9), (500, 5000), (0, 9)],
#                                                           p0=[100, 1.5, 2000, 1.5])

print('Stable: range of short-range model is '+str(params[0]))
print('Stable: range of long-range model is '+str(params[2]))
print('Stable: range of second long-range model is '+str(params[4]))
print('Moving: range of short-range model is '+str(params2[0]))
print('Moving: range of long-range model is '+str(params2[2]))
print('Moving: range of second long-range model is '+str(params2[4]))

print('Stable: sill of short-range model is '+str(params[1]/(params[1]+params[3]+params[5])))
print('Stable: sill of long-range model is '+str(params[3]/(params[1]+params[3]+params[5])))
print('Stable: sill of second long-range model is '+str(params[5]/(params[1]+params[3]+params[5])))
print('Moving: sill of short-range model is '+str(params2[1]/(params2[1]+params2[3]+params2[5])))
print('Moving: sill of long-range model is '+str(params2[3]/(params2[1]+params2[3]+params2[5])))
print('Moving: sill of long-range model is '+str(params2[5]/(params2[1]+params2[3]+params2[5])))

areas = np.square(np.concatenate((np.linspace(5, 500, 1000),np.linspace(501, 15000, 1000))))

list_stderr_singlerange, list_stderr_doublerange, list_stderr_singlerange_gla,\
    list_stderr_doublerange_gla = ([] for i in range(4))
for area in areas:

    # Number of effective samples integrated over the area for a single-range model
    # !! Careful !! Need to scale the Gaussian range by a factor 1/2 to match scikit-gstat
    neff_singlerange = xdem.spatialstats.neff_circ(area, [(params[0]/2, 'Gau', params[1])])

    # For a double-range model
    neff_doublerange = xdem.spatialstats.neff_circ(area, [(params[0]/2, 'Gau', params[1]),
                                                   (params[2], 'Sph', params[3]),
                                                   (params[4], 'Sph', params[5])])

    # Number of effective samples integrated over the area for a single-range model
    neff_singlerange_gla = xdem.spatialstats.neff_circ(area, [(params2[0]/2, 'Gau', params2[1])])

    # For a double-range model
    neff_doublerange_gla = xdem.spatialstats.neff_circ(area, [(params2[0]/2, 'Gau', params2[1]),
                                                          (params2[2], 'Sph', params2[3]),
                                                          (params2[4], 'Sph', params2[5])])
    # Convert into a standard error
    stderr_singlerange = 1/np.sqrt(neff_singlerange)
    stderr_doublerange = 1/np.sqrt(neff_doublerange)
    stderr_singlerange_gla = 1/np.sqrt(neff_singlerange_gla)
    stderr_doublerange_gla = 1/np.sqrt(neff_doublerange_gla)

    list_stderr_singlerange.append(stderr_singlerange)
    list_stderr_doublerange.append(stderr_doublerange)
    list_stderr_singlerange_gla.append(stderr_singlerange_gla)
    list_stderr_doublerange_gla.append(stderr_doublerange_gla)


# 1/ First panel: plot the empirical and model variogram, on a nonlinear X-axis with histogram on top
fig = plt.figure(figsize=(14,7.75))
ylabel = "Standardized\nvariance"
xlabel = 'Spatial lag (m)'
xscale_range_split = [120, 640, 3600]
xscale = 'linear'
list_fit_fun = [params, params2]
list_fit_fun_label = None
xlim = None
ylim = (0, 1.15)
list_df = [df_std_sta, df_std_gla]
col_df = ['tab:brown', 'tab:cyan']
label_df = ['Stable terrain', 'Moving terrain']
df0 = list_df[0]

# 1.1/ Colorbar on the percentage of correlation
cmap = plt.get_cmap('Greys')
col_bounds = np.array([0, 5, 20, 50, 100])
cb = []
cb_val = np.linspace(0, 1, len(col_bounds))
for j in range(len(cb_val)):
    cb.append(cmap(cb_val[j]))
cmap_cus = colors.LinearSegmentedColormap.from_list('my_cb', list(
    zip((col_bounds - min(col_bounds)) / (max(col_bounds - min(col_bounds))), cb)), N=1000)

init_gridsize = [10, 20]

# Create parameters to split x axis into different linear scales
# If there is no split, get parameters for a single subplot
if xscale_range_split is None:
    nb_subpanels = 1
    if xscale == 'log':
        xmin = [np.min(df0.bins) / 2]
    else:
        xmin = [0]
    xmax = [np.max(df0.bins)]
    xgridmin = [0]
    xgridmax = [init_gridsize[0]]
    gridsize = init_gridsize
# Otherwise, derive a list for each subplot
else:
    # Add initial zero if not in input
    if xscale_range_split[0] != 0:
        if xscale == 'log':
            first_xmin = np.min(df0.bins) / 2
        else:
            first_xmin = 0
        xscale_range_split = [first_xmin] + xscale_range_split
    # Add maximum distance if not in input
    if xscale_range_split[-1] != np.max(df0.bins):
        xscale_range_split.append(15000)

    # Scale grid size by the number of subpanels
    nb_subpanels = len(xscale_range_split) - 1
    gridsize = init_gridsize.copy()
    gridsize[1] = 26
    gridsize[0] *= nb_subpanels
    # Create list of parameters to pass to ax/grid objects of subpanels
    xmin, xmax, xgridmin, xgridmax = ([] for i in range(4))
    for i in range(nb_subpanels):
        xmin.append(xscale_range_split[i])
        xmax.append(xscale_range_split[i + 1])
        xgridmin.append(init_gridsize[0] * i)
        xgridmax.append(init_gridsize[0] * (i + 1))

# Need a grid plot to show the sample count and the statistic
grid = plt.GridSpec(gridsize[1], gridsize[0]+30, wspace=0.1, hspace=0.1)

# 1.2/ Loop over each subpanel of the variogram
for k in [1,0,2,3]:
    # First, an axis to plot the sample histogram
    ax0 = fig.add_subplot(grid[:3, xgridmin[k]:xgridmax[k]])
    ax0.set_xscale(xscale)
    ax0.set_xticks([])

    # Plot the histogram manually with fill_between
    interval_var = [0] + list(df0.bins)
    for i in range(len(df0)):
        width = interval_var[i+1] - interval_var[i]
        mid = interval_var[i] + width/2
        count = list_df[0]['count'].values[i]
        count_gla = list_df[1]['count'].values[i]
        ax0.fill_between([mid-width/3, mid], [0] * 2, [count] * 2,
                         facecolor='tab:brown', alpha=1,
                         edgecolor='black', linewidth=0.5)
        ax0.fill_between([mid, mid+width/3], [0] * 2, [count_gla] * 2,
                         facecolor='tab:cyan', alpha=1,
                         edgecolor='black', linewidth=0.5)
        ax0.vlines(mid-width/2, ymin=[0], ymax=1.2*max(list_df[0]['count'].values), colors='tab:gray', linestyles='dashed', linewidths=0.5)
    if k == 0:
        ax0.set_ylabel('Sample\ncount')
        # Scientific format to avoid undesired additional space on the label side
        ax0.ticklabel_format(axis='y', style='sci', scilimits=(0, 0))
    else:
        ax0.set_yticks([])
    # Ignore warnings for log scales
    ax0.set_xlim((xmin[k], xmax[k]))
    ax0.set_ylim((0, 1.2*max(list_df[0]['count'].values)))

    # For more easy understanding, plot the %age correlation of variance based on the variogram model
    ax1 = fig.add_subplot(grid[12:13, xgridmin[k]:xgridmax[k]])
    ax1.set_xscale(xscale)
    # ax1.set_xticks([])
    if nb_subpanels > 1 and k == (nb_subpanels - 1):
        ax1.xaxis.set_ticks(np.linspace(xmin[k], xmax[k], 3))
    elif nb_subpanels > 1:
        ax1.xaxis.set_ticks(np.linspace(xmin[k], xmax[k], 3)[:-1])

    x_tmp = np.linspace(xmin[k], xmax[k], 100)
    for i in range(len(x_tmp)-1):
        fit_fun_sta = list_fit_fun[0]
        def vgm_sum_sta_std(h):
            fn = (skg.models.spherical(h, fit_fun_sta[0], fit_fun_sta[1]) +
                  skg.models.spherical(h, fit_fun_sta[2], fit_fun_sta[3])) / (fit_fun_sta[1] + fit_fun_sta[3])
            return fn
        # Middle value of spatial lag
        xmid = x_tmp[i] + 0.5*(x_tmp[i+1] - x_tmp[i])
        # Percentage of correlation
        corr = (1 - vgm_sum_sta_std(xmid)) * 100

        stat_corr = max(0.0001, min(0.9999, (corr - min(col_bounds)) / (max(col_bounds) - min(col_bounds))))
        col_corr = cmap_cus(stat_corr)

        ax1.fill_between([x_tmp[i], x_tmp[i+1]], [0] * 2, [1] * 2,
                         facecolor=col_corr, alpha=1, edgecolor=None)

    ax1.set_yticks([])

    if k == 1:
        ax1.set_xlabel(xlabel, x=1, ha='center')
        ax1.text(1, -2.2, '(a)', transform=ax1.transAxes, ha='center', va='top', fontsize=15)

    if k == nb_subpanels - 1:
        cbaxes = ax1.inset_axes([-0.25, -5, 1.5, 0.5], zorder=10)

        norm = colors.Normalize(vmin=min(col_bounds), vmax=max(col_bounds))
        sm = plt.cm.ScalarMappable(cmap=cmap_cus, norm=norm)
        sm.set_array([])
        cb = plt.colorbar(sm, cax=cbaxes, ticks=[0, 20, 50, 100], orientation='horizontal', extend='neither',
                          shrink=0.2)
        cb.set_label('Spatial correlation (\%)\n'
                     'inferred from\n'
                     'stable terrain\n'
                     'with short- and\nlong-range model')

    if k == 0:
        ax1.set_ylabel('Correlation', labelpad=25)
        # ax1.yaxis.set_label_position("right")

    ax1.set_xlim((xmin[k], xmax[k]))
    ax1.set_ylim((0, 1))

    for i in range(len(df0)):
        width = interval_var[i + 1] - interval_var[i]
        mid = interval_var[i] + width / 2
        ax1.vlines(mid - width / 2, ymin=[0], ymax=1, colors='tab:gray', linestyles='dashed',
                  linewidths=0.5)

    # Now, plot the statistic of the data
    ax = fig.add_subplot(grid[3:12, slice(xgridmin[k],xgridmax[k])])

    # Get the bins center
    for i, df in enumerate(list_df):
        bins_center = np.subtract(df.bins, np.diff([0] + df.bins.tolist()) / 2)
        ax.errorbar(bins_center, df.exp, yerr=df.err_exp, fmt='x', color=col_df[i])

    for i in range(len(df0)):
        width = interval_var[i + 1] - interval_var[i]
        mid = interval_var[i] + width / 2
        ax.vlines(mid - width / 2, ymin=[0], ymax=2*max(df0.exp), colors='tab:gray', linestyles='dashed', linewidths=0.5)

    ax.hlines(1, xmin=xmin[k], xmax=xmax[k], colors='black', linestyles='dotted')
    # If a list of functions is passed, plot the modelled variograms
    if list_fit_fun is not None:
        for i, fit_fun in enumerate(list_fit_fun):
            x = np.linspace(xmin[k], xmax[k], 1000)

            def vgm_short(h):
                fn = skg.models.gaussian(h, fit_fun[0], fit_fun[1])
                return fn

            def vgm_long(h):
                fn = skg.models.spherical(h, fit_fun[2], fit_fun[3])
                return fn

            def vgm_sum(h):
                fn = skg.models.gaussian(h, fit_fun[0], fit_fun[1]) + skg.models.spherical(h, fit_fun[2], fit_fun[3]) + skg.models.spherical(h, fit_fun[4], fit_fun[5])
                return fn

            colors_terrain = ['tab:brown', 'tab:cyan']

            ax.plot(x, vgm_short(x), linestyle='dashdot', color=colors_terrain[i], zorder=30, linewidth=1)
            ax.plot(x, vgm_sum(x), linestyle='dashed', color=colors_terrain[i], zorder=30, linewidth=1.5)
            # ax.plot(x, vgm_long(x), linestyle='dashdot', color=colors[i], label = 'Long-range model', zorder=30, linewidth=1)
            if i == 0:
                ax.errorbar([], [], [], color='black', label='Empirical variogram', fmt='x')
                ax.plot([], [], linestyle='dashdot', color='black', label='Modelled variogram: short-range')
                ax.plot([], [], linestyle='dashed', color='black', label='Modelled variogram: short- and long-range',
                        linewidth=1.5)
                ax.plot([], [], color='tab:brown', label='Stable terrain')
                ax.plot([], [], color='tab:cyan', label='Moving terrain')




    ax.set_xscale(xscale)

    if k == 0:
        ax.annotate(text='', xy=(30, 0.93), xytext=(30, 0), arrowprops=dict(arrowstyle='<|-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)
        ax.text(38, 0.65, '93\% of variance\ndecorrelates\nafter 30 m', ha='left', va='center',
                bbox= dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), zorder=31)

    if k == 3:
        ax.annotate(text='', xy=(3900, 0.93), xytext=(3900, 0.95), arrowprops=dict(
            arrowstyle=mpatches.ArrowStyle.BarAB(widthA=0.5, widthB=0.5), connectionstyle=None,
            shrinkA=0, shrinkB=0, patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)
        ax.annotate(text='', xy=(3900, 0.85), xytext=(3900, 0.93), arrowprops=dict(arrowstyle='<|-', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)
        ax.annotate(text='', xy=(3900, 0.95), xytext=(3900, 1.03), arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)

        ax.text(3900, 0.65, '2\% of variance\ndecorrelates\nafter 3 900 m', ha='right', va='center',
                bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), zorder=31)

        ax.annotate(text='', xy=(11200, 0.95), xytext=(11200, 1), arrowprops=dict(
            arrowstyle=mpatches.ArrowStyle.BarAB(widthA=0.5, widthB=0.5), connectionstyle=None,
            shrinkA=0, shrinkB=0, patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)
        ax.annotate(text='', xy=(11200, 0.87), xytext=(11200, 0.95),
                    arrowprops=dict(arrowstyle='<|-', connectionstyle=None,
                                    shrinkA=0, shrinkB=0,
                                    patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)
        ax.annotate(text='', xy=(11200, 1), xytext=(11200, 1.08),
                    arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                                    shrinkA=0, shrinkB=0,
                                    patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=30)

        ax.text(10500, 0.675, '5\% of variance\nis correlated\nuntil 11 200 m', ha='center', va='center',
                bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), zorder=31)

    ax.set_xticks([])

    if xlim is None:
        ax.set_xlim((xmin[k], xmax[k]))
    else:
        ax.set_xlim(xlim)

    if ylim is not None:
        ax.set_ylim(ylim)
    else:
        ax.set_ylim((0, np.nanmax(df_vgm_sta.exp) + np.nanmean(df_vgm_sta.err_exp)))

    if k == nb_subpanels - 1:
        handles, labels = plt.gca().get_legend_handles_labels()
        order = [4, 0, 1, 2, 3]
        ax.legend([handles[idx] for idx in order], [labels[idx] for idx in order], loc='lower right', ncol=2)
    if k == 0:
        ax.set_ylabel(ylabel)
    else:
        ax.set_yticks([])


# 2/ Panel c: the spatially integrated uncertainty

areas_km2 = np.asarray(areas)/ 1000000
areas_emp_km2 = np.asarray(df_all_patches.area.values)/ 1000000

# 2.1/ Plot a friezes colored with the correlation between center and perimeter of circular area
ax1 = fig.add_subplot(grid[-1:, xgridmax[-1]+8:])

ax1.set_xscale('log')

for i in range(len(areas_km2)-1):
    fit_fun_sta = list_fit_fun[0]
    def vgm_sum_sta_std(h):
        fn = (skg.models.spherical(h, fit_fun_sta[0], fit_fun_sta[1]) +
              skg.models.spherical(h, fit_fun_sta[2], fit_fun_sta[3])) / (fit_fun_sta[1] + fit_fun_sta[3])
        return fn
    # Middle value of spatial lag
    area_mid = areas_km2[i] + 0.5*(areas_km2[i+1] - areas_km2[i])
    # Percentage of correlation
    r = np.sqrt(10**6*area_mid/np.pi)

    corr = (1 - vgm_sum_sta_std(r)) * 100

    stat_corr = max(0.0001, min(0.9999, (corr - min(col_bounds)) / (max(col_bounds) - min(col_bounds))))
    col_corr = cmap_cus(stat_corr)

    ax1.fill_between([areas_km2[i], areas_km2[i+1]], [0] * 2, [1] * 2,
                     facecolor=col_corr, alpha=1, edgecolor=None)

ax1.set_yticks([])
ax1.set_xlabel(r'Circular averaging area (km$^{2}$)')
ax1.vlines([10.**i for i in np.arange(-4,3)], ymin=[0], ymax=1, colors='tab:gray', linestyles='dashed', linewidths=0.5)

ax1.set_ylabel('Correlation between\ncenter and edge\nof averaging area', labelpad=50)
ax1.set_xlim((min(areas_km2), max(areas_km2)))
ax1.set_ylim((0, 1))
x_major = ticker.LogLocator(base = 10.0, numticks = 4)
ax1.xaxis.set_major_locator(x_major)
x_minor = ticker.LogLocator(base = 10.0, subs = np.arange(1.0, 10.0) * 0.1, numticks = 10)
ax1.xaxis.set_minor_locator(x_minor)
ax1.xaxis.set_minor_formatter(ticker.NullFormatter())

# 2.2/ Annotate the corresponding legend for the correlation length
axcirc = ax1.inset_axes([-0.175, -0.6, 0.16, 2.6], zorder=10)
axcirc.set_xticks([])
axcirc.set_yticks([])
axcirc.spines['top'].set_visible(False)
axcirc.spines['left'].set_visible(False)
axcirc.spines['right'].set_visible(False)
axcirc.spines['bottom'].set_visible(False)

axcirc.add_patch(mpatches.Circle((0.5, 0.5), 0.45, edgecolor='black',
                                linewidth=1, facecolor='None', alpha=1))
axcirc.add_patch(mpatches.Circle((0.5, 0.5), 0.01, edgecolor='black',
                                linewidth=1, facecolor='black', alpha=1))
# axcirc.text(0.5, 0.5, 'Averaging\narea', ha='center', va='top')
axcirc.annotate('', xy=(0.5, 0.5), xytext=(0.5, 0.05), arrowprops=dict(arrowstyle='<|-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'))

# 2.3/ Main plot: logit/log plot to show standardized uncertainty
ax = fig.add_subplot(grid[:-1, xgridmax[-1]+8:])

# ax.hlines(1, xmin=min(areas_km2), xmax=max(areas_km2), colors='black', linestyles='dashed')

ax.plot(areas_km2, list_stderr_singlerange, color='tab:brown', linestyle='dashdot')
ax.plot(areas_km2, list_stderr_doublerange, color='tab:brown', linestyle='dashed', linewidth=1.5)
ax.plot(areas_km2, list_stderr_singlerange_gla, color='tab:cyan', linestyle='dashdot')
ax.plot(areas_km2, list_stderr_doublerange_gla, color='tab:cyan', linestyle='dashed', linewidth=1.5)
ax.scatter(areas_emp_km2, df_all_patches.stderr_emp_sta.values, color='tab:brown', marker='x')
ax.scatter(areas_emp_km2, df_all_patches.stderr_emp_gla.values , color='tab:cyan', marker='x')

# Annotate the underestimation of error
x = 0.1
ind = np.abs(np.array(areas_km2) - x).argmin()
y1 = list_stderr_singlerange[ind]
y2 = list_stderr_doublerange[ind]

r = round(y2/y1, 1) * 100

ax.annotate(text='', xy=(x, y2), xytext=(x, y1), arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'))
ax.text(x/20, y1, '{:,.0f}\%\nlarger error\nfor {:.1f}'.format(r, x).replace(',',' ')+' km$^{2}$', ha='center', va='center',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5))

x = 10
ind = np.abs(np.array(areas_km2) - x).argmin()
y1 = list_stderr_singlerange[ind]
y2 = list_stderr_doublerange[ind]

r = round(y2/y1, 1) * 100
ax.annotate(text='', xy=(x, y2), xytext=(x, y1), arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'))
ax.text(x/20, y1, '{:,.0f}\%\nlarger error\nfor {:.0f}'.format(r, x).replace(',',' ')+' km$^{2}$', ha='center', va='center',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5))

# ax.plot([], [], color='tab:brown', label='Stable terrain')
# ax.plot([], [], color='tab:cyan', label='Moving terrain')
ax.plot([], [], color='black', linestyle='dashdot', label='Analytical approach:\nshort-range model')
ax.plot([], [], color='black', linestyle='dashed', label='Analytical approach:\nshort- and long-range model', linewidth=1.5)
ax.scatter([], [], color='black', marker='x', label='Empirical validation:\nMonte-Carlo patches')

ax.set_ylabel('Standardized\n uncertainty', labelpad=-20)
ax.set_xscale('log')
ax.set_yscale('logit')
ax.set_xlim(min(areas_km2), max(areas_km2))
ax.set_ylim((min(list_stderr_singlerange), 0.991))
ax.vlines([10.**i for i in np.arange(-4,3)], ymin=[0.00001], ymax=0.99999, colors='tab:gray', linestyles='dashed', linewidths=0.5)
ax.legend()
# x_major = ticker.LogLocator(base = 10.0, numticks = 3)
# ax.xaxis.set_major_locator(x_major)
# x_minor = ticker.LogLocator(base = 10.0, subs = np.arange(1.0, 5) * 0.2, numticks = 10)
# ax.xaxis.set_minor_locator(x_minor)
# ax.xaxis.set_minor_formatter(ticker.NullFormatter())
ax.set_xticks([])
ax.text(0.5, -0.125, '(c)', transform=ax.transAxes, ha='center', va='top',fontsize=15)


# 3/ Panel b: extracts of dh maps to illustrate the correlations

# 3.1/ First, plot the entire background map

ax = fig.add_subplot(grid[16:-1, :xgridmax[-1]-12], projection=ccrs.UTM(32), label='Mont-Blanc')

y_extent = std_r.bounds.top - std_r.bounds.bottom
x_extent = std_r.bounds.right - std_r.bounds.left
plt_extent = [
    std_r.bounds.left+1/40*x_extent,
    std_r.bounds.right-1/5*x_extent,
    std_r.bounds.bottom + 6/10*y_extent,
    std_r.bounds.top-1/20*y_extent,
]
crop_ext = [plt_extent[0], plt_extent[2], plt_extent[1], plt_extent[3]]
std_r.crop(crop_ext)

# Add a custom scale bar
ax.add_patch(mpatches.Rectangle((crop_ext[2] - 7.5*x_extent/10, crop_ext[1] + y_extent/20),1000, 200,
                                edgecolor='black',facecolor='black',transform=ccrs.UTM(32),zorder=10,linewidth=0.5))
ax.add_patch(mpatches.Rectangle((crop_ext[2] - 7.5*x_extent/10 + 1000, crop_ext[1] + y_extent/20),1000, 200,
                                edgecolor='black',facecolor='white',transform=ccrs.UTM(32),zorder=10,linewidth=0.5))
ax.text(crop_ext[2] - 7.5*x_extent/10,  crop_ext[1] + y_extent/20 - 100,'0',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
ax.text(crop_ext[2] - 7.5*x_extent/10 + 1000, crop_ext[1] + y_extent/20 - 100,'1',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
ax.text(crop_ext[2] - 7.5*x_extent/10 + 1000, crop_ext[1] + y_extent/20 - 700,'km',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
ax.text(crop_ext[2] - 7.5*x_extent/10 + 2000, crop_ext[1] + y_extent/20 - 100,'2',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)

# 3.2/ Add colorbar

cmap = plt.get_cmap('RdYlBu', 100)
# cmap._init()
# cmap._lut[:, -1] = 1.
col_bounds = np.array([-2., -1., 0., 1., 2.])
cb = []
cb_val = np.linspace(0, 1, len(col_bounds))
for j in range(len(cb_val)):
    cb.append(cmap(cb_val[j]))
cmap_cus2 = colors.LinearSegmentedColormap.from_list('my_cb', list(
    zip((col_bounds - min(col_bounds)) / (max(col_bounds - min(col_bounds))), cb)), N=1000)

# cmap2._lut[0, -1] = 0.0  # We made transparent de 10 first levels of hillshade,
cmap_cus2.set_bad(color='None')
ax.imshow(std_r.data[0, :, :], extent=plt_extent, transform=ccrs.UTM(32), vmin=min(col_bounds), vmax=max(col_bounds), cmap=cmap_cus2,
          interpolation=None, zorder=3, alpha=0.85)

# shape_feature = ShapelyFeature(Reader(fn_shp).geometries(), ccrs.PlateCarree(), edgecolor=plt.cm.Greys(0.95), alpha=1,
#                                facecolor='None', linewidth=1, zorder=4)
# ax.add_feature(shape_feature)
ax.gridlines(draw_labels={'bottom':'x', 'left':'y'}, dms=True, x_inline=False, y_inline=False)

ax.text(0.5, -0.475, '(b)', transform=ax.transAxes, ha='center', va='bottom', fontsize=15)

cbaxes = ax.inset_axes([0.2, -0.17, 0.6, 0.05], zorder=10)

norm = colors.Normalize(vmin=min(col_bounds), vmax=max(col_bounds))
sm = plt.cm.ScalarMappable(cmap=cmap_cus2, norm=norm)
sm.set_array([])
cb = plt.colorbar(sm, cax=cbaxes, ticks=col_bounds, orientation='horizontal', extend='both', shrink=0.2)
cb.set_label('Standardized elevation difference', labelpad=-0.5)

inside_ext = [333600., 5097800., 334100., 5098300.]

ax.add_patch(mpatches.Rectangle((inside_ext[0], inside_ext[1]), 500, 500,
                                edgecolor='black',facecolor='None',transform=ccrs.UTM(32),
                                zorder=10, linewidth=1.5))
# ax.add_patch(mpatches.Arrow(332870, 5097880, dx=0, dy=-3500, edgecolor='black', facecolor='black', transform=ccrs.UTM(32), zorder=10,
#                             width=3))

# x_jit = 332870
# y_jit = 5097300
# x_jit = 343000
# ax.annotate(text='', xy=(x_noise, y_noise), xytext=(x_noise, y_noise-3500), arrowprops=dict(arrowstyle='<|-|>', linewidth=1, facecolor='black'),
#             transform=ccrs.UTM(32), zorder=10)
# ax.text(x_noise-300, y_noise-3500*0.8, '3.5 km', ha='right', va='center',
#         bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), transform=ccrs.UTM(32), zorder=10)


# 3.3./ Add arrows to illustrate correlation length of long-range noises
x_noise = 332870
y_noise = 5097600
x_noise2 = 342500
ax.annotate(text='', xy=(x_noise, y_noise), xytext=(x_noise, y_noise-3900), arrowprops=dict(arrowstyle='<|-|>', linewidth=1, facecolor='black'),
            transform=ccrs.UTM(32), zorder=10)
ax.text(x_noise-300, y_noise-3900*0.5, '3.9 km', ha='right', va='center',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), transform=ccrs.UTM(32), zorder=10)

ax.annotate(text='', xy=(x_noise2, y_noise), xytext=(x_noise2, y_noise-3900), arrowprops=dict(arrowstyle='<|-|>', linewidth=1, facecolor='black'),
            transform=ccrs.UTM(32), zorder=10)
ax.text(x_noise2+300, y_noise-3900*0.5, '3.9 km', ha='left', va='center',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), transform=ccrs.UTM(32), zorder=10)

y_noise2 = 5097800 + 1800
ax.annotate(text='', xy=(x_noise, y_noise2), xytext=(x_noise+11200, y_noise2), arrowprops=dict(arrowstyle='<|-|>', linewidth=1, facecolor='black'),
            transform=ccrs.UTM(32), zorder=10)
ax.text(x_noise+5600, y_noise2+300, '11.2 km', ha='center', va='bottom',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), transform=ccrs.UTM(32), zorder=10)

# 3.4/ Add inset to show short-range correlation
inside_ax = fig.add_subplot(grid[18:-1, 11:xgridmax[-1]-19], projection=ccrs.UTM(32), label='subset')

inside_ax.spines['geo'].set_edgecolor('black')
inside_ax.spines['geo'].set_linewidth(1.5)
std_r.crop(inside_ext)
inside_ax.imshow(std_r.data[0, :, :], extent=[inside_ext[0], inside_ext[2], inside_ext[1], inside_ext[3]],
                 transform=ccrs.UTM(32), vmin=min(col_bounds), vmax=max(col_bounds), cmap=cmap_cus2,
          interpolation=None, zorder=4, alpha=0.85)
inside_ax.gridlines(draw_labels=False, dms=False, x_inline=False, y_inline=False)

inside_x_extent = inside_ext[2] - inside_ext[0]
inside_y_extent = inside_ext[3] - inside_ext[1]

inside_ax.add_patch(mpatches.Rectangle((inside_ext[2] - 4.75*inside_x_extent/10 -25, inside_ext[1] + inside_y_extent/5), 100, 20,
                                edgecolor='black',facecolor='black',transform=ccrs.UTM(32),zorder=10,linewidth=0.5))
inside_ax.add_patch(mpatches.Rectangle((inside_ext[2] - 4.75*inside_x_extent/10 + 75, inside_ext[1] + inside_y_extent/5), 100, 20,
                                edgecolor='black',facecolor='white',transform=ccrs.UTM(32),zorder=10,linewidth=0.5))
inside_ax.text(inside_ext[2] - 4.75*inside_x_extent/10 - 25,  inside_ext[1] + inside_y_extent/5 - 10,'0',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
inside_ax.text(inside_ext[2] - 4.75*inside_x_extent/10 + 75, inside_ext[1] + inside_y_extent/5 - 10,'100',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
inside_ax.text(inside_ext[2] - 4.75*inside_x_extent/10 + 75, inside_ext[1] + inside_y_extent/5 - 50,'m',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)
inside_ax.text(inside_ext[2] - 4.75*inside_x_extent/10 + 175, inside_ext[1] + inside_y_extent/5 - 10,'200',ha='center',va='top',transform=ccrs.UTM(32),zorder=10)

# 3.5/ Add arrows to show short-range correlation lengths
x_res = 333660
y_res = 5097965

inside_ax.annotate(text='', xy=(x_res, y_res), xytext=(x_res + 30, y_res),
            arrowprops=dict(arrowstyle=mpatches.ArrowStyle.BarAB(widthA=0.5, widthB=0.5), connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)
inside_ax.annotate(text='', xy=(x_res - 20, y_res), xytext=(x_res, y_res),
            arrowprops=dict(arrowstyle='<|-', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)
inside_ax.annotate(text='', xy=(x_res + 30, y_res), xytext=(x_res + 60, y_res),
            arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)

x_res2 = 333787
y_res2 = 5098062
inside_ax.annotate(text='', xy=(x_res2, y_res2), xytext=(x_res2, y_res2 - 30),
            arrowprops=dict(arrowstyle=mpatches.ArrowStyle.BarAB(widthA=0.5, widthB=0.5), connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)
inside_ax.annotate(text='', xy=(x_res2, y_res2 + 20), xytext=(x_res2, y_res2),
            arrowprops=dict(arrowstyle='<|-', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)
inside_ax.annotate(text='', xy=(x_res2, y_res2 - 30), xytext=(x_res2, y_res2 - 60),
            arrowprops=dict(arrowstyle='-|>', connectionstyle=None,
                             shrinkA=0, shrinkB=0,
                             patchA=None, patchB=None, linewidth=1, facecolor='black'), zorder=10)
inside_ax.text(x_res+25, y_res+55, '30 m', ha='center', va='bottom',
        bbox=dict(facecolor='white', boxstyle='round', alpha=0.8, linewidth=0.5), transform=ccrs.UTM(32), zorder=10)

ax.add_patch(mpatches.ConnectionPatch(xyA=(inside_ext[2], inside_ext[3]), xyB=(0, 1), coordsA=ax.transData, coordsB=inside_ax.transAxes,
                                      zorder=10, facecolor='black'))
ax.add_patch(mpatches.ConnectionPatch(xyA=(inside_ext[2], inside_ext[1]), xyB=(0, 0), coordsA=ax.transData, coordsB=inside_ax.transAxes,
                                      zorder=10, facecolor='black'))

# Save to file
plt.savefig('/home/atom/ongoing/work_stderr_dem/figures/final/Figure_5_final.pdf', dpi=400, transparent=True)

